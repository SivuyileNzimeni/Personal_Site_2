{"title":"Department of Basic Education: Schools Database","markdown":{"yaml":{"title":"Department of Basic Education: Schools Database","image":"./DBE_Logo.png","description":"This post details the data scraping process for obtaining the schools database of from the Department of Basic Education in South Africa.","date":"December 30, 2021","author":"Sivuyile Nzimeni","categories":["web-scraping","data cleaning"],"toc":true,"execute":{"echo":true,"warning":false}},"headingText":"INTRODUCTION","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nlapply(as.list(c(\"tidyverse\",\"janitor\",\"readxl\",\"writexl\",\n                 \"rvest\",\"xml2\")),require,character.only=TRUE)\n```\n\n\nA few years ago, I was a student pursuing Masters of Commerce degree. The topic had something to do with the relationship between Education, Labour and Business outcomes. My pursuit of the qualification is defunct. However, there are several artefacts worth writting up. In this post, we will discuss the South African Schools Database. The Department of Basic Education regularly publishes versions of the School Database including a number of notable variables such as the school's location, contact information, number of learners and teachers etc. The data is published in a non-standardised matter. This makes it an interesting data wrangling task. \n\n## DATA SCRAPING\n\nThe first hurdle is the volume of files publised on the [DBE](https://www.education.gov.za/Programmes/EMIS/EMISDownloads.aspx) website. It is possible to download all 200 files by hand and save them to a directory of your choosing. However, such a process would be tedious and error prone(speaking from experience, ofcourse). The R-Programming language is a perfect companion for this task. To download the files, we can use two important packages, rvest and xml2.\n\n```{r read_website,echo=TRUE}\n#| eval: false\n#| include: false\nData_Sets <- read_html(\"https://www.education.gov.za/Programmes/EMIS/EMISDownloads.aspx\") %>% \n  html_elements(\"a\") %>% \n  html_attr(name = \"href\")\n\nData_Sets <- data.frame(dataset_links = Data_Sets) %>% \n  filter(str_detect(dataset_links,\"^[[:punct:]]Link\"),\n         str_detect(dataset_links,\"forcedownload\"))\n\nData_Sets <- Data_Sets %>% \n  mutate(dataset_links = paste0(\"https://www.education.gov.za/Programmes/EMIS/EMISDownloads\",\n                                dataset_links))\n```\n\nFirstly, we specify the url on the read_html function. Thereafter,  we use the html_elements function to point to the html tag of interest. In this case, we are interest in the \"a\" tag, specifically, the href (or link) attribute. \n\nWe store the result in a data.frame object and use a regular expression to filter for values that start with a punctuation followed by \"Link\" and values that contain the term \"forcedownload\". Finally, we append the path to file (our base url). The resulting data.frame contains all 200 downloadable files. \n\n## DOWNLOADS, SO MANY DOWNLOADS.\n\nWith the links in hand, we can tackle the next hurdle, downloading the files. Usually, we could use the commandline to download the files. For example, the single command below. \n\n```{bash,eval=FALSE,echo=TRUE}\nwget -i some_text_file.txt\n```\n\nHowever, the DBE datasets are saved as either xlsx or xls format with a prompt on click to download the file. There are probably ways around this issue. Luckily, xml2 has a convenient function to handle this issue. In the code below, we use a for-loop to download each file in our dataset and save them in a specified sub folder. To avoid a break in the for-loop when an error occurs, we add the try function. As an add-on, we print a statement after each download. Depending on your internet connection speed and the website's response time, this script can take five minutes to download all the files. \n\n```{r download_files,echo=TRUE,eval=FALSE}\nfor(i in seq_along(1:nrow(Data_Sets))){\n  try(download_xml(url = Data_Sets$dataset_links[[i]],\n               file = paste0(\"./Schools_Db/\",\"file_\",i,\".xlsx\")))\n  print(paste0(\"File \",i, \" downloaded \",\"proceeding to file \",i+1,\".\"))\n}\n\n```\n\n## BRING YOUR BROOMS CAUSE IT'S A MESS!\n\nAnother set of tasks to address is reading and cleaning the excel files. Using other software such as Excel or SPSS, these tasks would be cumbersome. Yet with R, Python or other programming languages, it possible handle more than one file at a time. Below, we use the readxl and purrr R packages to iteratively read and clean the files.\n\n```{r read_files,echo=TRUE}\n# All_Excel_Reader --------------------------------------------------------\nall_excel <- function(path){\n  collect_sheets <- excel_sheets(path)\n  number_of_sheets <- 1:length(collect_sheets)\n  per_sheet <- list()\n  for(i in seq_along(number_of_sheets)){\n    per_sheet[[i]] <- read_xlsx(path = path,\n                                sheet = collect_sheets[i])\n  }\n  return(per_sheet)}\n# All_Masterlist ----------------------------------------------------------\nEDU_Dbs <- data.frame(master_list = list.files(path = \"./Schools_Db\",\n           full.names=TRUE,\n           pattern = \".xlsx\")) %>% \n  mutate(schools_db = map(master_list,all_excel))\n\nEDU_Dbs <- EDU_Dbs %>% \n  unnest(schools_db)\n\nEDU_Dbs$schools_db <- lapply(EDU_Dbs$schools_db,sapply,as.character)\n\nEDU_Dbs$schools_db <- lapply(EDU_Dbs$schools_db,as.data.frame)\n\nEDU_Dbs <- EDU_Dbs %>% \n  unnest(schools_db)\n\nEDU_Dbs <- EDU_Dbs %>% \n  clean_names()\n```\n\nThe resulting data.frame contains hundreds of thousands of rows and nearly 60 columns. Interestingly, most of these variable are effectively differing naming conventions such as emisno = natemis = oldnatemis = newnatemis. The insistent naming conventions extend to other variables such as gps coordinates and centre details. The spectacularly unoptimised  script is available[here](https://github.com/SivuyileNzimeni/DBE_Data/blob/main/Schools_Db_Cleaner.R). The scraper script,cleaning script and downloaded xlsx files are all available on the [this github report](https://github.com/SivuyileNzimeni/DBE_Data).\n\n\n# CONCLUSION\n\nUsing R to clean data is a wise choice. This post highlighted an example of implementation on a relatively small dataset. The final dataset can be used to match school performance reports regularly published by the Department of Basic Education. \n\n# REFERENCES\n\nWickham et al., (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686, https://doi.org/10.21105/joss.01686\n  \nSam Firke (2021). janitor: Simple Tools for Examining and Cleaning Dirty Data. R package version 2.1.0. https://CRAN.R-project.org/package=janitor\n\nHadley Wickham and Jennifer Bryan (2019). readxl: Read Excel Files. R package version 1.3.1. https://CRAN.R-project.org/package=readxl\n\nJeroen Ooms (2021). writexl: Export Data Frames to Excel 'xlsx' Format. R package version 1.4.0. https://CRAN.R-project.org/package=writexl\n\nHadley Wickham (2021). rvest: Easily Harvest (Scrape) Web Pages. R package version 1.0.2. https://CRAN.R-project.org/package=rvest","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nlapply(as.list(c(\"tidyverse\",\"janitor\",\"readxl\",\"writexl\",\n                 \"rvest\",\"xml2\")),require,character.only=TRUE)\n```\n\n# INTRODUCTION\n\nA few years ago, I was a student pursuing Masters of Commerce degree. The topic had something to do with the relationship between Education, Labour and Business outcomes. My pursuit of the qualification is defunct. However, there are several artefacts worth writting up. In this post, we will discuss the South African Schools Database. The Department of Basic Education regularly publishes versions of the School Database including a number of notable variables such as the school's location, contact information, number of learners and teachers etc. The data is published in a non-standardised matter. This makes it an interesting data wrangling task. \n\n## DATA SCRAPING\n\nThe first hurdle is the volume of files publised on the [DBE](https://www.education.gov.za/Programmes/EMIS/EMISDownloads.aspx) website. It is possible to download all 200 files by hand and save them to a directory of your choosing. However, such a process would be tedious and error prone(speaking from experience, ofcourse). The R-Programming language is a perfect companion for this task. To download the files, we can use two important packages, rvest and xml2.\n\n```{r read_website,echo=TRUE}\n#| eval: false\n#| include: false\nData_Sets <- read_html(\"https://www.education.gov.za/Programmes/EMIS/EMISDownloads.aspx\") %>% \n  html_elements(\"a\") %>% \n  html_attr(name = \"href\")\n\nData_Sets <- data.frame(dataset_links = Data_Sets) %>% \n  filter(str_detect(dataset_links,\"^[[:punct:]]Link\"),\n         str_detect(dataset_links,\"forcedownload\"))\n\nData_Sets <- Data_Sets %>% \n  mutate(dataset_links = paste0(\"https://www.education.gov.za/Programmes/EMIS/EMISDownloads\",\n                                dataset_links))\n```\n\nFirstly, we specify the url on the read_html function. Thereafter,  we use the html_elements function to point to the html tag of interest. In this case, we are interest in the \"a\" tag, specifically, the href (or link) attribute. \n\nWe store the result in a data.frame object and use a regular expression to filter for values that start with a punctuation followed by \"Link\" and values that contain the term \"forcedownload\". Finally, we append the path to file (our base url). The resulting data.frame contains all 200 downloadable files. \n\n## DOWNLOADS, SO MANY DOWNLOADS.\n\nWith the links in hand, we can tackle the next hurdle, downloading the files. Usually, we could use the commandline to download the files. For example, the single command below. \n\n```{bash,eval=FALSE,echo=TRUE}\nwget -i some_text_file.txt\n```\n\nHowever, the DBE datasets are saved as either xlsx or xls format with a prompt on click to download the file. There are probably ways around this issue. Luckily, xml2 has a convenient function to handle this issue. In the code below, we use a for-loop to download each file in our dataset and save them in a specified sub folder. To avoid a break in the for-loop when an error occurs, we add the try function. As an add-on, we print a statement after each download. Depending on your internet connection speed and the website's response time, this script can take five minutes to download all the files. \n\n```{r download_files,echo=TRUE,eval=FALSE}\nfor(i in seq_along(1:nrow(Data_Sets))){\n  try(download_xml(url = Data_Sets$dataset_links[[i]],\n               file = paste0(\"./Schools_Db/\",\"file_\",i,\".xlsx\")))\n  print(paste0(\"File \",i, \" downloaded \",\"proceeding to file \",i+1,\".\"))\n}\n\n```\n\n## BRING YOUR BROOMS CAUSE IT'S A MESS!\n\nAnother set of tasks to address is reading and cleaning the excel files. Using other software such as Excel or SPSS, these tasks would be cumbersome. Yet with R, Python or other programming languages, it possible handle more than one file at a time. Below, we use the readxl and purrr R packages to iteratively read and clean the files.\n\n```{r read_files,echo=TRUE}\n# All_Excel_Reader --------------------------------------------------------\nall_excel <- function(path){\n  collect_sheets <- excel_sheets(path)\n  number_of_sheets <- 1:length(collect_sheets)\n  per_sheet <- list()\n  for(i in seq_along(number_of_sheets)){\n    per_sheet[[i]] <- read_xlsx(path = path,\n                                sheet = collect_sheets[i])\n  }\n  return(per_sheet)}\n# All_Masterlist ----------------------------------------------------------\nEDU_Dbs <- data.frame(master_list = list.files(path = \"./Schools_Db\",\n           full.names=TRUE,\n           pattern = \".xlsx\")) %>% \n  mutate(schools_db = map(master_list,all_excel))\n\nEDU_Dbs <- EDU_Dbs %>% \n  unnest(schools_db)\n\nEDU_Dbs$schools_db <- lapply(EDU_Dbs$schools_db,sapply,as.character)\n\nEDU_Dbs$schools_db <- lapply(EDU_Dbs$schools_db,as.data.frame)\n\nEDU_Dbs <- EDU_Dbs %>% \n  unnest(schools_db)\n\nEDU_Dbs <- EDU_Dbs %>% \n  clean_names()\n```\n\nThe resulting data.frame contains hundreds of thousands of rows and nearly 60 columns. Interestingly, most of these variable are effectively differing naming conventions such as emisno = natemis = oldnatemis = newnatemis. The insistent naming conventions extend to other variables such as gps coordinates and centre details. The spectacularly unoptimised  script is available[here](https://github.com/SivuyileNzimeni/DBE_Data/blob/main/Schools_Db_Cleaner.R). The scraper script,cleaning script and downloaded xlsx files are all available on the [this github report](https://github.com/SivuyileNzimeni/DBE_Data).\n\n\n# CONCLUSION\n\nUsing R to clean data is a wise choice. This post highlighted an example of implementation on a relatively small dataset. The final dataset can be used to match school performance reports regularly published by the Department of Basic Education. \n\n# REFERENCES\n\nWickham et al., (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686, https://doi.org/10.21105/joss.01686\n  \nSam Firke (2021). janitor: Simple Tools for Examining and Cleaning Dirty Data. R package version 2.1.0. https://CRAN.R-project.org/package=janitor\n\nHadley Wickham and Jennifer Bryan (2019). readxl: Read Excel Files. R package version 1.3.1. https://CRAN.R-project.org/package=readxl\n\nJeroen Ooms (2021). writexl: Export Data Frames to Excel 'xlsx' Format. R package version 1.4.0. https://CRAN.R-project.org/package=writexl\n\nHadley Wickham (2021). rvest: Easily Harvest (Scrape) Web Pages. R package version 1.0.2. https://CRAN.R-project.org/package=rvest"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","editor":"visual","code-copy":true,"code-summary":"see code","theme":{"light":"materia","dark":"darkly"},"title":"Department of Basic Education: Schools Database","image":"./DBE_Logo.png","description":"This post details the data scraping process for obtaining the schools database of from the Department of Basic Education in South Africa.","date":"December 30, 2021","author":"Sivuyile Nzimeni","categories":["web-scraping","data cleaning"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}